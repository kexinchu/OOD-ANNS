# Recall下降原因分析报告

## 执行时间
生成时间: 2025-12-16
数据来源: `runtime_update_results.csv` (354分钟数据，约5.9小时)

## 1. 数据概览

### 1.1 总体趋势
- **初始Recall** (前5分钟平均): **0.9738**
- **最终Recall** (后5分钟平均): **0.8679**
- **总下降**: **0.1059 (10.87%)**
- **索引增长**: 从 10,189,410 增长到 11,552,239 (**13.42%增长**)
- **总Insert次数**: 约 1.36M 次

### 1.2 相关性分析
- **Recall vs Index Size**: **-0.9930** (极强负相关)
- **Recall vs NDC**: **-0.8622** (强负相关)
- **Recall vs Latency**: **-0.7715** (中等负相关)

**结论**: Recall下降与索引规模增长高度相关。

### 1.3 下降速率分析
| 时间段 | 平均Recall | 下降速率(/分钟) |
|--------|-----------|----------------|
| 0-1h   | 0.9699    | 0.262          |
| 1-2h   | 0.9562    | 0.286          |
| 2-3h   | 0.9358    | **0.376** (最快) |
| 3-4h   | 0.9147    | 0.338          |
| 4-5h   | 0.8943    | 0.314          |
| 5h+    | 0.8758    | 0.311          |

**观察**: 2-3小时期间下降最快，之后趋于稳定但仍持续下降。

## 2. 根本原因分析

### 2.1 Insert操作频率过高，连接数不足 ⚠️ **主要原因**

**当前配置**:
- Insert频率: **100 QPS** = 每分钟约 **6,000次**
- 每次Insert参数:
  - `efC = 200` (搜索候选数)
  - `M = 16` (最终连接数)
  - 只连接16个邻居节点

**问题**:
1. **连接数不足**: 新插入节点只连接16个邻居，可能无法充分融入图结构
2. **高频Insert**: 每分钟6,000次insert，图结构变化太快
3. **局部优化不足**: Insert时只考虑局部最优，没有全局视角

**影响**:
- 新节点可能形成"孤岛"或弱连接区域
- 随着索引增大，图的连通性整体下降
- NDC持续上升（从22,350到25,890），说明搜索路径变长

### 2.2 图修复频率不足 ⚠️ **次要原因**

**当前实现** (`ConnectivityEnhancementThread`):
- 修复频率: **每5秒运行一次**
- 修复条件: 只处理 `recall < 0.98` 的查询
- 修复方法: 使用 `NGFixOptimized` 添加边

**问题**:
1. **修复速度跟不上**: 
   - Insert速度: 6,000次/分钟 = 500次/5秒
   - 修复速度: 每5秒处理一批hard queries（数量有限）
   - **修复速度 << Insert速度**

2. **修复阈值过高**:
   - 当recall降到0.87时，几乎所有查询都需要修复
   - 但修复能力有限，无法处理所有hard queries

3. **修复间隔可能太长**:
   - 5秒间隔内，可能有大量新insert发生
   - 新insert可能破坏刚修复的图结构

### 2.3 索引规模增大导致图结构退化

**现象**:
- 索引从10M增长到11.5M+ (**13.42%增长**)
- NDC从22,350增长到25,890 (**15.8%增长**)
- 说明搜索需要访问更多节点才能找到结果

**原因**:
1. **图结构不够优化**: 新插入节点可能破坏了原有的最优路径
2. **平均路径长度增加**: 图的直径可能增大
3. **连通性下降**: 某些区域可能变得难以到达

### 2.4 Insert操作可能破坏图结构

**Insert流程** (`HNSWBottomLayerInsertion`):
1. 使用 `efC=200` 搜索候选邻居
2. 使用heuristic选择 `M=16` 个邻居
3. 更新新节点的连接
4. **更新邻居节点的连接**（可能替换原有连接）

**潜在问题**:
- 替换邻居时可能移除重要的长距离连接
- 新节点的插入可能改变局部图结构
- 没有考虑全局连通性影响

## 3. 建议的解决方案

### 3.1 增加Insert时的连接数 (高优先级)
**方案**:
- 增加 `M` 值: 从16增加到24或32
- 或增加 `efC` 值: 从200增加到300-400
- 让新节点有更多连接，更好地融入图结构

**预期效果**: 减少新节点的"孤立"问题，提高图连通性

### 3.2 提高图修复频率 (高优先级)
**方案**:
- 减少修复间隔: 从5秒减少到1-2秒
- 增加修复线程数量: 使用多个修复线程并行处理
- 降低修复阈值: 从0.98降低到0.95，更早发现问题
- 批量处理: 每批处理更多hard queries

**预期效果**: 更快修复图结构问题，跟上Insert速度

### 3.3 优化Insert策略 (中优先级)
**方案**:
- **Insert后立即局部优化**: 在Insert后对局部区域进行NGFix优化
- **更智能的邻居选择**: 考虑全局连通性，不只是局部距离
- **保留重要连接**: 替换邻居时，优先保留长距离连接

**预期效果**: 减少Insert对图结构的破坏

### 3.4 定期全局优化 (低优先级)
**方案**:
- 定期（如每小时）对图进行全局优化
- 重新计算entry point
- 修复关键路径和连通性问题

**预期效果**: 长期保持图结构质量

## 4. 验证方法

### 4.1 监控指标
1. **图修复线程处理速度**: 统计每5秒处理的hard query数量
2. **Hard query比例**: 统计recall < 0.98的查询比例
3. **NDC趋势**: 监控NDC是否持续上升
4. **图连通性指标**: 计算图的平均度、聚类系数等

### 4.2 实验验证
1. **测试不同M值**: M=16, 24, 32对recall的影响
2. **测试不同修复频率**: 1秒、2秒、5秒的修复效果
3. **测试Insert后优化**: 对比有无局部优化的效果

## 5. 当前测试状态

- **测试进程**: 正在运行（PID: 351512）
- **已运行时间**: 约5.9小时
- **预计完成时间**: 还需约4.1小时（总共10小时）
- **建议**: 不要中断当前测试，让测试完成以获得完整数据

## 6. 下一步行动

1. ✅ **已完成**: 分析recall下降原因
2. ⏳ **待测试**: 实施解决方案并验证效果
3. ⏳ **待优化**: 根据测试结果调整参数

---

**注意**: 此分析基于当前测试数据，建议在测试完成后进行更深入的分析。

